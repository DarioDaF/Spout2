/*
=========================================================================

						WinSpoutVideo.cpp

   A Windows Desktop Application project generated by Visual Studio
   and adapted for Spout input (http://spout.zeal.co/).
   Search on "SPOUT" for additions.

   This example uses the SpoutDX support class and FFmpeg
   to load a video, decode individual frames, send using
   SendImage and display in WM_PAINT.
      
   Compare with the more simple image sender example.
   Compare also with the DirectX 11 Tutorial04 sender example using SendTexture.


   FFmpeg and FFprobe are required :
   Download binaries from : https://ffmpeg.zeranoe.com/builds/
   Choose the Windows static build
   Unzip the archive and copy bin\FFmpeg.exe and bin\FFprobe.exe to : DATA\FFMPEG

   
=========================================================================

				 Copyright(C) 2021 Lynn Jarvis.

This program is free software : you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.If not, see < http://www.gnu.org/licenses/>.
========================================================================

*/

#include "framework.h"
#include "WinSpoutDXvideo.h"

#define MAX_LOADSTRING 100

// SPOUT
#include <vector>
#include <Shlwapi.h>
#include <commdlg.h>
#include <stdio.h>
#include <string>
#include <io.h>
#include "..\..\SpoutDX.h"

// Global Variables:
HINSTANCE hInst;                                // current instance
WCHAR szTitle[MAX_LOADSTRING];                  // The title bar text
WCHAR szWindowClass[MAX_LOADSTRING];            // the main window class name
// SPOUT
spoutDX sender;                         // Sending object
HWND g_hWnd = NULL;                     // Window handle
unsigned char *g_pixelBuffer = nullptr; // RGBA pixel buffer
unsigned char *g_bgraBuffer = nullptr;  // Conversion buffer
unsigned char g_SenderName[256];        // Sender name
unsigned int  g_SenderWidth = 1280;     // Sender width (video width)
unsigned int  g_SenderHeight = 720;     // Sender height (video height)
float g_FrameRate = 30.0;               // Video frame rate
std::string g_exePath;                  // Executable location
std::string g_ffmpegPath;               // FFmpeg location
std::string g_input;                    // Input string to FFmpeg
FILE *g_pipein = nullptr;               // Pipe for FFmpeg

// Forward declarations of functions included in this code module:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);
// SPOUT
void Render();                          // Read a frame from ffmpeg, display and send
bool SelectVideoFile(char *filepath, int maxchars);
bool OpenVideo(std::string filePath);   // Open a video with FFmpeg
bool ffprobe(std::string filePath);     // Get movie file information

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR    lpCmdLine,
	_In_ int       nCmdShow)
{
	UNREFERENCED_PARAMETER(hPrevInstance);
	UNREFERENCED_PARAMETER(lpCmdLine);

	// TODO: Place code here.

	// SPOUT
	// _popen will open a console window
	// To hide the output, open a console first and then hide it
	OpenSpoutConsole();
	ShowWindow(GetConsoleWindow(), SW_HIDE);

	// Initialize global strings
	LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadStringW(hInstance, IDC_WINSPOUTDX, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// Perform application initialization:
	if (!InitInstance(hInstance, nCmdShow))
	{
		return FALSE;
	}

	// ===============================================
	// SPOUT
	//

	// Executable location
	char exePath[MAX_PATH];
	GetModuleFileNameA(NULL, exePath, MAX_PATH); // Path of the executable
	PathRemoveFileSpecA(exePath);
	g_exePath = exePath;

	// FFmpeg location - \DATA\FFMPEG
	g_ffmpegPath = g_exePath;
	g_ffmpegPath += "\\DATA\\FFMPEG\\ffmpeg.exe";
	if (_access(g_ffmpegPath.c_str(), 0) == -1) {
		MessageBoxA(NULL, "FFmpeg not found", "Warning", MB_OK | MB_TOPMOST);
		return FALSE;
	}

	// Look for FFprobe.exe
	std::string ffprobePath = g_exePath;
	ffprobePath += "\\DATA\\FFMPEG\\ffprobe.exe";
	if (_access(ffprobePath.c_str(), 0) == -1) {
		MessageBoxA(NULL, "FFprobe not found", "Warning", MB_OK | MB_TOPMOST);
		return false;
	}

	// Example video file - \DATA\MOVIES
	std::string videoPath = g_exePath;
	videoPath += "\\DATA\\MOVIES\\warp_speed.mp4";
	if (_access(videoPath.c_str(), 0) == -1) {
		MessageBoxA(NULL, "Video not found", "Warning", MB_OK | MB_TOPMOST);
		return FALSE;
	}

	// Open a pipe for FFmpeg to decode the video frames to rgba
	if (!OpenVideo(videoPath)) {
		MessageBoxA(NULL, "Could not open sample video", "Warning", MB_OK | MB_TOPMOST);
		return FALSE;
	}

	// Set the sender texture format to rgba
	sender.SetSenderFormat(DXGI_FORMAT_R8G8B8A8_UNORM);

	// Give the sender a name
	// If no name is specified, the executable name is used
	sender.SetSenderName("Simple video sender");

	// ===============================================

	// Main message loop:
	MSG msg = { 0 };
	while (WM_QUIT != msg.message)
	{
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		else
		{
			Render();
		}
	}

	// SPOUT
	if (g_pipein) {
		fflush(g_pipein);
		_pclose(g_pipein);
	}
	if (g_pixelBuffer) delete g_pixelBuffer;
	if (g_bgraBuffer) delete g_bgraBuffer;
	sender.ReleaseSender();

    return (int) msg.wParam;
}

// SPOUT
void Render()
{
	// Read a frame from the FFmpeg input pipe
	if (g_pipein && g_pixelBuffer) {
		if (fread(g_pixelBuffer, 1, g_SenderWidth*g_SenderHeight*4, g_pipein) == 0) {
			// Start again for end of file
			// Use the same file and pixel buffer
			fflush(g_pipein);
			_pclose(g_pipein);
			g_pipein = _popen(g_input.c_str(), "rb");
		}
		// Send the pixels
		// SendImage looks after sender creation and update
		sender.SendImage(g_pixelBuffer, g_SenderWidth, g_SenderHeight);
	}

	// Trigger a re-paint to draw the frame - see WM_PAINT
	InvalidateRect(g_hWnd, NULL, FALSE);
	UpdateWindow(g_hWnd); // Update immediately

	// Hold the application cycle to the video frame rate
	sender.HoldFps((int)g_FrameRate);

}


bool SelectVideoFile(char *filepath, int maxchars)
{
	char szFile[MAX_PATH] = "";
	OPENFILENAMEA ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = g_hWnd;

	// Show the user the existing file in the FileOpen dialog
	if (filepath[0]) {
		strcpy_s(szFile, filepath);
		PathStripPathA(szFile);
	}

	// Set defaults
	ofn.lpstrFilter = "All files (*.*)\0*.*\0Video files (*.mp4)\0*.mp4\0";
	ofn.lpstrFile = szFile; // This is returned
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
	if (GetOpenFileNameA(&ofn)) {
		strcpy_s(filepath, maxchars, szFile);
		return true;
	}
	return false;
}

bool OpenVideo(std::string filePath)
{

	// Get information from the movie file using ffprobe
	// to set the width, height and framerate globals
	if (!ffprobe(filePath))
		return false;

	if (g_pipein) {
		fflush(g_pipein);
		_pclose(g_pipein);
	}

	// Open an input pipe from ffmpeg
	g_input = g_ffmpegPath;
	g_input += " -i ";
	g_input += "\"";
	g_input += filePath;
	g_input += "\"";
	g_input += " -f image2pipe -vcodec rawvideo -pix_fmt rgba -";
	g_pipein = _popen(g_input.c_str(), "rb");
	if (g_pipein) {
		if (g_pixelBuffer) delete g_pixelBuffer;
		g_pixelBuffer = new unsigned char[g_SenderWidth*g_SenderHeight * 4];
		if (g_bgraBuffer) delete g_bgraBuffer;
		g_bgraBuffer = new unsigned char[g_SenderWidth*g_SenderHeight * 4];
		return true;
	}
	else {
		MessageBoxA(NULL, "FFmpeg open failed", "Warning", MB_OK | MB_TOPMOST);
	}

	return false;
}

// Run FFprobe on a movie file and produce an ini file with the stream information
bool ffprobe(std::string videoPath)
{
	// Get information from the movie file using ffprobe and write to an ini file
	// Use a batch file with the required ffprobe options and pass the path to ShellExecute
	std::string probepath = "\"";
	probepath += g_exePath;
	probepath += "\\DATA\\FFMPEG\\probe.bat";
	probepath += "\"";

	// Input to ffprobe
	std::string input = "\"";
	input += videoPath;
	input += "\"";

	// In the batch file, %~dp0 returns the Drive and Path to the batch script

	// Open ffprobe and wait for completion
	STARTUPINFOA si = { sizeof(STARTUPINFOA) };
	HANDLE hProcess = NULL;  // Handle from CreateProcess
	si = { sizeof(STARTUPINFOA) };
	DWORD dwExitCode = 0;
	ZeroMemory((void *)&si, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_HIDE; // hide the ffprobe console window
	PROCESS_INFORMATION pi;
	std::string cmdstring = probepath + " " + input;
	if (CreateProcessA(NULL, (LPSTR)cmdstring.c_str(), NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
		hProcess = pi.hProcess;
		do {
			GetExitCodeProcess(hProcess, &dwExitCode);
		} while (dwExitCode == STILL_ACTIVE);
	}
	else {
		MessageBoxA(NULL, "FFprobe CreateProcess failed", "Warning", MB_OK | MB_TOPMOST);
		return false;
	}

	// Read the ini file produced by FFprobe to get the video information
	char initfile[MAX_PATH];
	strcpy_s(initfile, MAX_PATH, g_exePath.c_str());
	strcat_s(initfile, MAX_PATH, "\\DATA\\FFMPEG\\myprobe.ini");
	if (_access(initfile, 0) == -1) {
		MessageBoxA(NULL, "FFprobe ini file not found", "Warning", MB_OK | MB_TOPMOST);
		return false;
	}

	// For example :
	// [streams.stream.0]
	// width=1280
	// height = 720
	// avg_frame_rate=30/1

	char tmp[MAX_PATH];
	if (GetPrivateProfileStringA((LPCSTR)"streams.stream.0", (LPSTR)"width", (LPSTR)"1280", (LPSTR)tmp, 8, initfile) > 0) {
		g_SenderWidth = atoi(tmp);
	}
	if (GetPrivateProfileStringA((LPCSTR)"streams.stream.0", (LPSTR)"height", (LPSTR)"720", (LPSTR)tmp, 8, initfile) > 0) {
		g_SenderHeight = atoi(tmp);
	}
	if (GetPrivateProfileStringA((LPCSTR)"streams.stream.0", (LPSTR)"avg_frame_rate", (LPSTR)"30/1", (LPSTR)tmp, 8, initfile) > 0) {
		std::string iniValue = tmp;
		auto pos = iniValue.find("/");
		double num = atof(iniValue.substr(0, pos).c_str());
		double den = atof(iniValue.substr(pos + 1, iniValue.npos).c_str());
		if (num > 0 && den > 0) {
			g_FrameRate = (float)(num / den);
		}
	}

	return true;
}


//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINSPOUTDX));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
	// SPOUT
    // wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
	wcex.hbrBackground  = CreateHatchBrush(HS_DIAGCROSS, RGB(192, 192, 192));
    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_WINSPOUTDX);
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_WINSPOUTDX));

    return RegisterClassExW(&wcex);
}

//
//   FUNCTION: InitInstance(HINSTANCE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // Store instance handle in our global variable

   // SPOUT - modified for 640x360 starting client size
   RECT rc = { 0, 0, 640, 360 }; // Desired client size
   AdjustWindowRect(&rc, WS_CAPTION | WS_SYSMENU, TRUE);

   HWND hWnd = CreateWindowW(szWindowClass, szTitle,
	   // WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,
	   // CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);
	   // SPOUT - enable resize and maximize to demonstrate sender resizing
	   WS_OVERLAPPEDWINDOW | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_THICKFRAME,
	   CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, nullptr, nullptr, hInstance, nullptr);


   if (!hWnd)
   {
      return FALSE;
   }

   // SPOUT
   // Centre the window on the desktop work area
   GetWindowRect(hWnd, &rc);
   RECT WorkArea;
   int WindowPosLeft = 0;
   int WindowPosTop = 0;
   SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&WorkArea, 0);
   WindowPosLeft += ((WorkArea.right - WorkArea.left) - (rc.right - rc.left)) / 2;
   WindowPosTop += ((WorkArea.bottom - WorkArea.top) - (rc.bottom - rc.top)) / 2;
   MoveWindow(hWnd, WindowPosLeft, WindowPosTop, (rc.right - rc.left), (rc.bottom - rc.top), false);

   g_hWnd = hWnd;
   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Processes messages for the main window.
//
//  WM_COMMAND  - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY  - post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // Parse the menu selections:
            switch (wmId)
            {
			case IDM_OPEN:
				{
					char filePath[MAX_PATH];
					if (SelectVideoFile(filePath, MAX_PATH)) {
						// returns a file path if successful
						if (!OpenVideo(filePath)) {
							MessageBoxA(NULL, "Could not open sample video", "Warning", MB_OK | MB_TOPMOST);
							break;
						}
					}
				}
				break;
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;

    case WM_PAINT:
        {
    		{
				PAINTSTRUCT ps;
				HDC hdc = BeginPaint(hWnd, &ps);

				// SPOUT
				// Draw the received image
				RECT dr = { 0 };
				GetClientRect(hWnd, &dr);
				if (!g_pixelBuffer) {
					// No data - draw default background
					HBRUSH backbrush = CreateHatchBrush(HS_DIAGCROSS, RGB(192, 192, 192));
					FillRect(hdc, &dr, backbrush);
					DeleteObject(backbrush);
				}
				else {
					//
					// Video data is RGBA but windows draw is BGRA and conversion is required
					//
					// For widths divisible by 16, a high speed copy function
					// can be used to convert from rgba to bgra.
					// Timing has shown that this is much faster (1-2 msec)
					// than using BITMAPV4HEADER (18-24 msec) at 1280x720.
					//
					if ((g_SenderWidth % 16) == 0) {
						BITMAPINFO bmi;
						ZeroMemory(&bmi, sizeof(BITMAPINFO));
						bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
						bmi.bmiHeader.biSizeImage = (LONG)(g_SenderWidth * g_SenderHeight * 4); // Pixel buffer size
						bmi.bmiHeader.biWidth = (LONG)g_SenderWidth;   // Width of buffer
						bmi.bmiHeader.biHeight = -(LONG)g_SenderHeight;  // Height of buffer and bottom up
						bmi.bmiHeader.biPlanes = 1;
						bmi.bmiHeader.biBitCount = 32;
						bmi.bmiHeader.biCompression = BI_RGB;
						// SSE conversion from rgba to bgra
						sender.spoutcopy.rgba2bgra(g_pixelBuffer, g_bgraBuffer, g_SenderWidth, g_SenderHeight);
						SetStretchBltMode(hdc, COLORONCOLOR);
						StretchDIBits(hdc,
							0, 0, (dr.right - dr.left), (dr.bottom - dr.top),
							0, 0, g_SenderWidth, g_SenderHeight, g_bgraBuffer,
							&bmi, DIB_RGB_COLORS, SRCCOPY);
					}
					else {
						// The extended BITMAPV4HEADER bitmap info header
						// is required instead of BITMAPINFO but can be slow.
						BITMAPV4HEADER info = { sizeof(BITMAPV4HEADER) };
						info.bV4Width = (LONG)g_SenderWidth;
						info.bV4Height = -(LONG)g_SenderHeight;
						info.bV4Planes = 1;
						info.bV4BitCount = 32;
						info.bV4V4Compression = BI_BITFIELDS;
						info.bV4RedMask = 0x000000FF;
						info.bV4GreenMask = 0x0000FF00;
						info.bV4BlueMask = 0x00FF0000;
						info.bV4AlphaMask = 0xFF000000;

						SetStretchBltMode(hdc, COLORONCOLOR);
						StretchDIBits(hdc,
							0, 0,
							(dr.right - dr.left),
							(dr.bottom - dr.top), // destination rectangle 
							0, 0,
							g_SenderWidth, g_SenderHeight, // source rectangle 
							g_pixelBuffer,
							reinterpret_cast<BITMAPINFO*>(&info),
							DIB_RGB_COLORS,
							SRCCOPY);
					}
				}
				EndPaint(hWnd, &ps);
			}
        }
        break;

	case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

// Message handler for about box.
// SPOUT : adapted for this example.
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(lParam);
	char tmp[MAX_PATH];
	char about[1024];
	LPDRAWITEMSTRUCT lpdis;
	HWND hwnd = NULL;
	HCURSOR cursorHand = NULL;

	switch (message)
	{
	case WM_INITDIALOG:

		sprintf_s(about, 256, "            WinSpoutDXvideo");
		strcat_s(about, 1024, "\n\n\n");
		strcat_s(about, 1024, "Windows Spout sender example using SpoutDX. ");
		strcat_s(about, 1024, "Load a video using FFmpeg, send frames and display in WM_PAINT.");
		SetDlgItemTextA(hDlg, IDC_ABOUT_TEXT, (LPCSTR)about);

		// Spout website hyperlink hand cursor
		cursorHand = LoadCursor(NULL, IDC_HAND);
		hwnd = GetDlgItem(hDlg, IDC_SPOUT_URL);
		SetClassLongPtrA(hwnd, GCLP_HCURSOR, (LONG_PTR)cursorHand);
		return (INT_PTR)TRUE;

	case WM_DRAWITEM:
		// The blue hyperlink
		lpdis = (LPDRAWITEMSTRUCT)lParam;
		if (lpdis->itemID == -1) break;
		SetTextColor(lpdis->hDC, RGB(6, 69, 173));
		switch (lpdis->CtlID) {
		case IDC_SPOUT_URL:
			DrawTextA(lpdis->hDC, "http://spout.zeal.co", -1, &lpdis->rcItem, DT_LEFT);
			break;
		default:
			break;
		}
		break;

	case WM_COMMAND:

		if (LOWORD(wParam) == IDC_SPOUT_URL) {
			// Open the website url
			sprintf_s(tmp, MAX_PATH, "http://spout.zeal.co");
			ShellExecuteA(hDlg, "open", tmp, NULL, NULL, SW_SHOWNORMAL);
			EndDialog(hDlg, 0);
			return (INT_PTR)TRUE;
		}

		if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
		{
			EndDialog(hDlg, LOWORD(wParam));
			return (INT_PTR)TRUE;
		}
		break;
	}
	return (INT_PTR)FALSE;
}

// That's all..
